{
  "version": 3,
  "file": "binary-interval-search.js",
  "sourceRoot": "..",
  "sources": [
    "src/binary-interval-search.coffee"
  ],
  "names": [],
  "mappings": ";AAAA;EAAA;AAAA,MAAA;;EAGA,MAAM,CAAC,OAAP,GAAiB,sBAAA,GAAyB,QAAA,CAAE,IAAF,EAAQ,YAAR,EAAsB,YAAtB,EAAoC,MAApC,EAA4C,KAA5C,CAAA,EAAA;;;;;;;;;;;;;;;;;;AAkBxC,QAAA,QAAA,EAAA,MAAA,EAAA,YAAA,EAAA,QAAA,EAAA,MAAA,EAAA;IAAA,MAAA,GAAY;IACZ,MAAA,GAAY,IAAI,CAAC,MAAL,GAAc,EAD1B;;AAGA,WAAM,MAAA,IAAU,MAAhB;MACE,OAAA,GAAkB,IAAI,CAAC,KAAL,CAAW,CAAE,MAAA,GAAS,MAAX,CAAA,GAAsB,CAAjC;MAClB,YAAA,GAAkB,IAAM,CAAA,OAAA;MACxB,QAAA,GAAkB,YAAc,CAAA,YAAA;MAChC,QAAA,GAAkB,YAAc,CAAA,YAAA,EAHhC;;MAKA,IAAG,CAAA,QAAA,IAAY,KAAZ,IAAY,KAAZ,IAAqB,QAArB,CAAH;QACS,IAAG,cAAH;iBAAgB,YAAc,CAAA,MAAA,EAA9B;SAAA,MAAA;iBAA4C,QAA5C;SADT;OALA;;MAQA,IAAG,KAAA,GAAQ,QAAX;QAAyB,MAAA,GAAS,OAAA,GAAU,EAA5C;OAAA,MAAA;QAAmD,MAAA,GAAS,OAAA,GAAU,EAAtE;;IATF,CAHA;;AAcA,WAAO;EAhCiC;AAH1C",
  "sourcesContent": [
    "\n\n#-----------------------------------------------------------------------------------------------------------\nmodule.exports = binary_interval_search = ( data, lo_bound_key, hi_bound_key, id_key, probe ) ->\n  ### Given `data`, three indexes, and a `probe`, perform a binary search through `data` to find into which\n  of the given intervals `probe` falls.\n\n  `data` must be a list of lists or objects with each entry representing an interval; intervals must not\n  overlap, and the intervals in `data` must be sorted in ascending ordered. There may be gaps between\n  intervals.\n\n  You must give the keys to the lower and upper boundaries, so that `data[ idx ][ lo_bound_key ]` yields the\n  first value and `data[ idx ][ hi_bound_key ]` the last value of each interval. `id_key` should be either\n  `null` or a key for an entry so that `data[ idx ][ id_key ]` yields the ID (or whatever info) you want to\n  retrieve with your search.\n\n  If a match is found, the result will be either the index of the matching interval, or, if `id_key` was\n  defined, `interval[ id_key ]`. If no match is found, `null` is returned.\n\n  With thx to http://googleresearch.blogspot.de/2006/06/extra-extra-read-all-about-it-nearly.html\n  ###\n  lo_idx    = 0\n  hi_idx    = data.length - 1\n  #.........................................................................................................\n  while lo_idx <= hi_idx\n    mid_idx         = Math.floor ( lo_idx + hi_idx ) / 2\n    id_and_range    = data[ mid_idx ]\n    lo_bound        = id_and_range[ lo_bound_key ]\n    hi_bound        = id_and_range[ hi_bound_key ]\n    #.......................................................................................................\n    if lo_bound <= probe <= hi_bound\n      return if id_key? then id_and_range[ id_key ] else mid_idx\n    #.......................................................................................................\n    if probe < lo_bound then hi_idx = mid_idx - 1 else lo_idx = mid_idx + 1\n  #.........................................................................................................\n  return null\n\n"
  ]
}